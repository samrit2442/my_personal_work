dummy_df_fin <- dummy_df3_mon |>
left_join(dummy_df_a, join_by(acc_id, month)) |>
left_join(dummy_df_b, join_by(acc_id, month, prod, sales)) |>
left_join(dummy_df_c, join_by(acc_id, month, prod, sales))
View(dummy_df_fin)
View(dummy_df_a)
dummy_df_fin <- dummy_df3_mon |>
left_join(dummy_df_a, join_by(acc_id, month)) |>
left_join(dummy_df_b, join_by(acc_id, month, prod, sales)) |>
left_join(dummy_df_c, join_by(acc_id, month, prod, sales))
dummy_df3_mon <- dummy_df2 |>
group_by(acc_id, month) |>
reframe(mrkt = sum(sales))
dummy_df_a <- dummy_df2 |>
filter(prod == 'a') |>
group_by(acc_id, month) |>
reframe(prod_a = sum(sales))
dummy_df_b <- dummy_df2 |>
filter(prod == 'b') |>
group_by(acc_id, month) |>
reframe(prod_b = sum(sales))
dummy_df_c <- dummy_df2 |>
filter(prod == 'c') |>
group_by(acc_id, month) |>
reframe(prod_c = sum(sales))
dummy_df_fin <- dummy_df3_mon |>
full_join(dummy_df_a) |>
full_join(dummy_df_b) |>
full_join(dummy_df_c)
dummy_df_fin[is.na(dummy_df_fin)] <- 0
dummy_df_fin2 <- dummy_df_fin |>
mutate(comp = mrkt - prod_a - prod_b - prod_c)
View(dummy_df_fin2)
dummy_df_fin3 <- dummy_df_fin2 |>
pivot_longer(cols = c(prod_a, prod_b, prod_c),
names_to = "prod",
values_to = "sales")
View(dummy_df_fin3)
library(dplyr)
# Example data
df <- data.frame(text = c("This is string1", "Another text with string2", "No match here"))
View(df)
# Example data
df <- data.frame(text = c("This is string1 & string2", "Another text with string2", "No match here"))
# Strings to check
string1 <- "string1"
string2 <- "string2"
# Filter the dataframe
filtered_df <- df %>%
filter(str_detect(text, string1) | str_detect(text, string2))
# If you want to produce the matches in two separate rows:
matches_df <- filtered_df %>%
mutate(
match_string = ifelse(str_detect(text, string1), string1, string2),
text = gsub(paste(string1, string2, collapse = "|"), "", text)
) %>%
select(text, match_string)
# Combining the original dataframe and matches dataframe
combined_df <- rbind(df, matches_df)
View(matches_df)
View(filtered_df)
# Filter the dataframe
filtered_df <- df %>%
filter(str_detect(text, "string1|string2"))
# If you want to produce the matches in two separate rows:
matches_df <- filtered_df %>%
mutate(
match_string = ifelse(str_detect(text, "string1"), string1, string2))
View(matches_df)
# Load required libraries
library(tidyverse)
# Example data
df <- data.frame(text = c("This is string1 and string2", "Another text with string1 but not string2", "No match here"))
View(df)
# Strings to check
string1 <- "string1"
string2 <- "string2"
# Filter the dataframe
filtered_df <- df %>%
filter(str_detect(text, string1) & str_detect(text, string2))
# Separate rows
separated_df <- filtered_df %>%
mutate(text = str_split(text, pattern = paste0(string1, "|", string2))) %>%
unnest(text)
View(separated_df)
View(filtered_df)
# Filter the dataframe
filtered_df <- df %>%
filter(str_detect(text, string1) | str_detect(text, string2))
View(filtered_df)
# Example data
df <- data.frame(text = c("This is string1", "Another text with string1 but not string2", "No match here"))
# Strings to check
string1 <- "string1"
string2 <- "string2"
# Filter the dataframe
filtered_df <- df %>%
filter(str_detect(text, string1) | str_detect(text, string2))
View(filtered_df)
View(df)
# Filter the dataframe
filtered_df <- df %>%
mutate(matched_str = case_when(
str_detect(text, string1) ~ "string1",
str_detect(text, string2) ~ "string2",
str_detect(text, string1) | str_detect(text, string2) ~ "string1, string2",
))
View(filtered_df)
# Load packages
library(tidyverse)
# Define a function to simulate one race (no money, just based on sequential dice rolls until winner)
race_horses <-
function(board) { # The board has a set number of "jumps" each horse needs to make to win
# Set parameters
board$Score <- 0
game_over <- FALSE
winner <- NA
total_spins <- 0
# Roll until there is a winner
while(!game_over) {
# Spin the die
d1 <- sample(1:6, 1)
d2 <- sample(1:6, 1)
# Compute the sum
total <- d1 + d2
# Compute spins
total_spins <- total_spins + 1
# Indicate the win
board <-
board |>
mutate(
Score =
case_when(
Horse == total ~ Score + 1,
TRUE ~ Score
)
)
# Check if there is a winner
is_winner <- filter(board, Needs == Score)
if(nrow(is_winner) > 0) {
game_over <- TRUE
winner <- pluck(is_winner, "Horse")
}
}
# Return results
tibble(
Horse = winner,
Spins = total_spins
)
}
# Define a function to aggregate and plot the results
plot_horse_races <-
function(race_results, board_desc) {
race_results |>
# Compute summaries
summarize(
Wins = n(),
Spins = mean(Spins),
.by = Horse
) |>
# Compute rates
mutate(
Rate = Wins / sum(Wins),
Horse = factor(Horse)
) |>
# Make a plot
ggplot(aes(x = Horse)) +
geom_col(
aes(y = Rate),
width = .5,
color = "black",
fill = "#020b4f",
linewidth = 1.25,
alpha = .5
) +
geom_text(
aes(
y = Rate,
label = paste0(round(100*Rate, 1), "%")
),
vjust = -.5
) +
geom_point(
aes(
y = Spins / 500,
group = 1
),
size = 3
) +
geom_line(
aes(
y = Spins / 500,
group = 1
)
) +
scale_y_continuous(
name = "Win Percentage (%)",
labels = scales::percent,
sec.axis = sec_axis(~.*500, name = "Avg. Total Rolls to Win")
) +
theme(
axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
plot.title = element_text(size = 16),
plot.subtitle = element_text(size = 12, face = "italic")
) +
labs(
title = paste0(games, " Horse Races"),
subtitle = paste0("Without scratches; ", board_desc)
)
}
# Number of games
games <- 10000
# Make the board
board1 <-
tibble(
Horse = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
Needs = c(3, 6, 9, 12, 15, 18, 15, 12, 9, 6, 3)
)
# Play the games
set.seed(123)
played_games1 <-
1:games |>
# Play the game many times
map_df(
function(x) {
cat("Game: ", x, "\n")
race_horses(board1) |> add_column(Game = x)
}
)
# Plot the results
played_games1 |> plot_horse_races("standard board")
# Make the board
board2 <-
tibble(
Horse = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
Needs = c(5, 7, 9, 11, 13, 15, 13, 11, 9, 7, 5)
)
# Play the games
set.seed(123)
played_games2 <-
1:games |>
# Play the game many times
map_df(
function(x) {
cat("Game: ", x, "\n")
race_horses(board2) |> add_column(Game = x)
}
)
# Plot the results
played_games2 |> plot_horse_races("adjusted board")
## Load packages
require(tidyverse)
require(tidytext)
## 1. Import and clean the dataset
dat <-
# Import dataset from website (Copied link from "Download full dataset")
read_csv(
file = "https://data.cms.gov/provider-data/sites/default/files/resources/b69e66780afdb7cbd0208ac9ae45d13e_1665414607/Healthcare_Associated_Infections-State.csv",
na = c("", "Not Available")
) %>%
# Filter to 50 U.S. states
filter(State %in% state.abb) %>%
# Parse out measures and components
mutate(
Component =
case_when(
str_detect(`Measure ID`, "LOWER") ~ "Lower",
str_detect(`Measure ID`, "UPPER") ~ "Upper",
str_detect(`Measure ID`, "SIR") ~ "Estimate"
),
Measure =
`Measure Name` %>%
str_remove_all(
pattern = ":.+"
) %>%
str_remove_all(
pattern = "\\s[(].+"
)
) %>%
# Send over the columns
pivot_wider(
id_cols =
c(
"State",
"Measure"
),
names_from = Component,
values_from = Score
)
devtools::install_github("ropenscilabs/opencv")
#Libraries
library(opencv)
library(psych)
# Live face detection:
ocv_video(ocv_face)
# Various options
ocv_video(ocv_edges)
ocv_video(ocv_knn)
ocv_video(ocv_facemask)
ocv_video(ocv_mog2)
ocv_video(ocv_stylize)
ocv_video(ocv_sketch)
# Overlay face filter
test <- ocv_camera()
bitmap <- ocv_bitmap(test)
png('bg.png', width = width, height = height)
width <- dim(bitmap)[2]
height <- dim(bitmap)[3]
png('bg.png', width = width, height = height)
data('iris')
print(pairs.panels(iris[1:4],
gap=0,
pch=21,
bg = c("red", "green", "blue")[iris$Species]))
dev.off()
bg <- ocv_read('bg.png')
ocv_video(function(input){
mask <- ocv_facemask(input)
ocv_copyto(input, bg, mask) })
gc()
ocv_video(function(input){
mask <- ocv_facemask(input)
ocv_copyto(input, bg, mask) })
# Face recognition
ccb <- ocv_read('~/Desktop/ccb.jpg')
faces <- ocv_face(ccb)
ocv_write(b, '~/Desktop/b.jpg')
# Various options
ocv_sketch(ccb, color = T)
ocv_blur(ccb, ksize = 15)
ocv_hog(ccb)
ocv_markers(ccb)
ocv_stylize(ccb)
# get the face location data:
facemask <- ocv_facemask(ccb)
attr(facemask, 'faces')
A <- matrix(1:9, nrow = 3)
A
apply(A, 2, rev)
names(mtcars)
library(tidyverse)
fn <- function(your_var_name) {
var_name = sym(your_var_name)
df <- mtcars |>
select(!!var_name) |>
summarise(mean = mean(!!var_name),
min = min(!!var_name))
return(df)
}
fn("hp")
fn("wt")
var_list <- paste0("CMDCOD", 1:7)
?sym
library(tibble)
library(dplyr)
dms_to_deg <- function(d, m, s, digit) {
if (m >= 60) {
stop("Minute should be less than 60.")
}
df2 <- tibble(d = d, m = m, s = s) %>%
mutate(deg = d + (m / 60) + (s / 3600)) %>%
mutate(deg = round(deg, digit))
return(df2 %>% pull(deg))
}
# Example usage with valid inputs
d <- 23
m <- 45
s <- 34
digit <- 4
# Call the function with valid minutes
result <- dms_to_deg(d, m, s, digit)
print(result)
# Example usage with invalid inputs (should trigger the stop condition)
d <- 23
m <- 75
s <- 34
digit <- 4
# This call should stop with an error message
result <- dms_to_deg(d, m, s, digit)
options(error = NULL)
options(browser = NULL)
undebug(dms_to_deg)
library(tibble)
library(dplyr)
dms_to_deg <- function(d, m, s, digit) {
if (m >= 60) {
stop("Minute should be less than 60.")
}
df2 <- tibble(d = d, m = m, s = s) %>%
mutate(deg = d + (m / 60) + (s / 3600)) %>%
mutate(deg = round(deg, digit))
return(df2 %>% pull(deg))
}
# Simplified test case to check if debugging mode is still triggered
d <- 23
m <- 75
s <- 34
digit <- 4
# Call the function
result <- dms_to_deg(d, m, s, digit)
m <- 5
s <- 34
digit <- 4
# Call the function
result <- dms_to_deg(d, m, s, digit)
print(result)
a = "lithium carbonate"
b = c("lithium carbonate 300 MG", "dfgoo 56 oplm")
gsub("\\d.*", "", b)
library(Matrix)
library(matrixStats)
x <- matrix(1:27, ncol = 3)
x
d1 <- colDiffs(x)
d1
df <- mtcars
dd = 0.38
plot(df$mpg, df$wt)
text(15, 3, bquote("Point" ~ .(dd)))
text(30, 5, bquote("Point" ~ Sigma ~ Y[tk]))
library(igraph)
# create data:
links <- data.frame(
source = c("A","A", "A", "A", "A","J", "B", "B", "C", "C", "D","I"),
target = c("B","B", "C", "D", "J","A","E", "F", "G", "H", "I","I"),
importance = (sample(1:4, 12, replace = T))
)
nodes <- data.frame(
name = LETTERS[1:10],
carac = c(rep("young", 3), rep("adult", 2), rep("old", 5))
)
# Turn it into igraph object
network <- graph_from_data_frame(d = links, vertices = nodes, directed = F)
# Make a palette of 3 colors
library(RColorBrewer)
coul  <- brewer.pal(12, "Paired")
# Create a vector of color
my_color <- coul[as.numeric(as.factor(V(network)$carac))]
V(network)$carac
# Make the plot
plot(network, vertex.color = my_color)
V(network)
legend("bottomleft", legend = levels(as.factor(V(network)$carac))  , col = coul, bty = "n", pch = 20, pt.cex = 3, cex = 1.5, text.col = coul, horiz = F, inset = c(0.1, 0.1))
library(tidyverse)
tst <- readxl::read_xlsx("Book1.xlsx")
tst |>
distinct(id, diag_grp) |>
mutate(a = 1) |>
pivot_wider(names_from = diag_grp, values_from = a) |>
mutate(tot = rowSums(across(!id), na.rm = T)) |>
filter(d == 1 & tot == 1) |>
select(id) |>
pull()
View(tst)
a = 1:10
rev(a)
A <- matrix(1:9, nrow = 3)
A
apply(A, 2, rev)
names(mtcars)
library(tidyverse)
fn <- function(your_var_name) {
var_name = sym(your_var_name)
df <- mtcars |>
select(!!var_name) |>
summarise(mean = mean(!!var_name),
min = min(!!var_name))
return(df)
}
fn("hp")
fn("wt")
midsem <- read.csv("Midsem grades.csv")
library(tidyverse)
library(readxl)
assgn1 <- read_excel("MTH442 grading.xlsx", sheet = "Assignment-1")
View(midsem)
midsem <- read.csv("Midsem grades.csv", header = F)
assgn1 <- read_excel("MTH442 grading.xlsx", sheet = "Assignment-1")
View(midsem)
colnames(midsem) <- c("Roll_No", "Marks")
View(midsem)
View(assgn1)
names(assign())
names(assgn1)
midsem_marks <- midsem |>
left_join(select(assgn1, `Email ID`, `Roll Number`),
join_by(`Roll_No` == `Roll Number`))
View(midsem_marks)
write.csv(midsem_marks, "midsem_marks.csv")
# install.packages("remotes)
remotes::install_github("luisdva/hexsession")
library(hexsession)
make_tile()
library(annotater)
library(annotater)
library(ggforce)
library(purrr)
library(forcats)
library(unheadr)
library(sdmTMB)
library(parsnip)
library(DBI)
library(broom)
library(vctrs)
library(patchwork)
hexsession::make_tile()
library(tidyverse)
library(shiny)
library(ggplot2)
library(quarto)
hexsession::make_tile()
